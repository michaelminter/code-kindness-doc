<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/style.css?t=90051322">
    <script src="../assets/script.js?t=93f1a66c"></script>
    <title>React - CodeKindness</title>
    <meta name="viewport" content="width=device-width">
  </head>
  <body class="-menu-visible">
    <div class="doc-layout">
      <div class="toggle menu-toggle js-menu-toggle"></div>
      <div class="menu toc-menu">
        <ul>
          <li class="menu-item -level-0 -parent">
            <ul class="submenu">
              <li class="menu-item -level-1"><a class="link title  link-index" href="../index.html">CodeKindness</a>
              </li>
              <li class="menu-item -level-1 -parent"><span class="title">Architecture</span>
                <ul class="submenu">
                  <li class="menu-item -level-2"><a class="link title  link-architectureoverview" href="../architecture/overview.html">Overview</a>
                  </li>
                  <li class="menu-item -level-2"><a class="link title  link-apioverview" href="../api/overview.html">APIs</a>
                  </li>
                  <li class="menu-item -level-2"><a class="link title  link-architecturebusiness" href="../architecture/business.html">Business</a>
                  </li>
                  <li class="menu-item -level-2"><a class="link title  link-architectureproject_management" href="../architecture/project_management.html">Project Management</a>
                  </li>
                  <li class="menu-item -level-2"><a class="link title  link-architecturesecurity" href="../architecture/security.html">Security</a>
                  </li>
                  <li class="menu-item -level-2"><a class="link title  link-architecturetesting" href="../architecture/testing.html">Testing</a>
                  </li>
                </ul>
              </li>
              <li class="menu-item -level-1 -parent"><span class="title">DevOps</span>
                <ul class="submenu">
                  <li class="menu-item -level-2"><a class="link title  link-devopsoverview" href="../devops/overview.html">Overview</a>
                  </li>
                </ul>
              </li>
              <li class="menu-item -level-1 -parent"><span class="title">Javascript</span>
                <ul class="submenu">
                  <li class="menu-item -level-2"><a class="link title  link-javascriptoverview" href="../javascript/overview.html">Overview</a>
                  </li>
                  <li class="menu-item -level-2"><a class="link title  link-javascriptoperators" href="../javascript/operators.html">Operators</a>
                  </li>
                  <li class="menu-item -level-2"><a class="link title  link-javascriptproperties" href="../javascript/properties.html">Properties</a>
                  </li>
                  <li class="menu-item -level-2"><a class="link title -active link-javascriptreact" href="../javascript/react.html">React</a>
                    <ul class="headings heading-list">
                      <li class="heading-item -depth-2"><a class="hlink link-lifecycle" href="#lifecycle">Lifecycle</a>
                        <ul class="heading-list -depth-2">
                          <li class="heading-item -depth-3"><a class="hlink link-mounting" href="#mounting">Mounting</a>
                          </li>
                          <li class="heading-item -depth-3"><a class="hlink link-updating" href="#updating">Updating</a>
                          </li>
                          <li class="heading-item -depth-3"><a class="hlink link-unmounting" href="#unmounting">Unmounting</a>
                          </li>
                          <li class="heading-item -depth-3"><a class="hlink link-error-handling" href="#error-handling">Error Handling</a>
                          </li>
                        </ul>
                      </li>
                      <li class="heading-item -depth-2"><a class="hlink link-dom" href="#dom">DOM</a>
                        <ul class="heading-list -depth-2">
                          <li class="heading-item -depth-3"><a class="hlink link-virtual-dom" href="#virtual-dom">Virtual DOM</a>
                          </li>
                          <li class="heading-item -depth-3"><a class="hlink link-render()" href="#render()">render()</a>
                          </li>
                        </ul>
                      </li>
                      <li class="heading-item -depth-2"><a class="hlink link-components" href="#components">Components</a>
                        <ul class="heading-list -depth-2">
                          <li class="heading-item -depth-3"><a class="hlink link-types" href="#types">Types</a>
                          </li>
                          <li class="heading-item -depth-3"><a class="hlink link-binding" href="#binding">Binding</a>
                          </li>
                          <li class="heading-item -depth-3"><a class="hlink link-context" href="#context">Context</a>
                          </li>
                          <li class="heading-item -depth-3"><a class="hlink link-constructor" href="#constructor">Constructor</a>
                          </li>
                          <li class="heading-item -depth-3"><a class="hlink link-fragments" href="#fragments">Fragments</a>
                          </li>
                          <li class="heading-item -depth-3"><a class="hlink link-error-boundaries" href="#error-boundaries">Error Boundaries</a>
                          </li>
                          <li class="heading-item -depth-3"><a class="hlink link-rendering" href="#rendering">Rendering</a>
                          </li>
                        </ul>
                      </li>
                      <li class="heading-item -depth-2"><a class="hlink link-hooks" href="#hooks">Hooks</a>
                        <ul class="heading-list -depth-2">
                          <li class="heading-item -depth-3"><a class="hlink link-state-hooks" href="#state-hooks">State Hooks</a>
                          </li>
                        </ul>
                      </li>
                      <li class="heading-item -depth-2"><a class="hlink link-props" href="#props">Props</a>
                        <ul class="heading-list -depth-2">
                          <li class="heading-item -depth-3"><a class="hlink link-validating" href="#validating">Validating</a>
                          </li>
                          <li class="heading-item -depth-3"><a class="hlink link-refreshing" href="#refreshing">Refreshing</a>
                          </li>
                          <li class="heading-item -depth-3"><a class="hlink link-spread" href="#spread">Spread</a>
                          </li>
                        </ul>
                      </li>
                      <li class="heading-item -depth-2"><a class="hlink link-state" href="#state">State</a>
                        <ul class="heading-list -depth-2">
                          <li class="heading-item -depth-3"><a class="hlink link-callbacks" href="#callbacks">Callbacks</a>
                          </li>
                        </ul>
                      </li>
                      <li class="heading-item -depth-2"><a class="hlink link-todo" href="#todo">TODO</a>
                      </li>
                    </ul>
                  </li>
                  <li class="menu-item -level-2"><a class="link title  link-javascriptvariables" href="../javascript/variables.html">Variables</a>
                  </li>
                </ul>
              </li>
              <li class="menu-item -level-1 -parent"><span class="title">Ruby</span>
                <ul class="submenu">
                  <li class="menu-item -level-2"><a class="link title  link-rubyoverview" href="../ruby/overview.html">Overview</a>
                  </li>
                  <li class="menu-item -level-2"><a class="link title  link-rubygems" href="../ruby/gems.html">Gems</a>
                  </li>
                  <li class="menu-item -level-2"><a class="link title  link-rubyrails" href="../ruby/rails.html">Rails</a>
                  </li>
                </ul>
              </li>
              <li class="menu-item -level-1 -parent"><span class="title">SQL</span>
                <ul class="submenu">
                  <li class="menu-item -level-2"><a class="link title  link-sqloverview" href="../sql/overview.html">Overview</a>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div class="body page-javascriptreact">
        <div class="header-nav">
          <div class="right"><a class="iconlink" href="https://github.com/michaelminter/grok-doc" data-title="michaelminter/grok-doc">
              <!-- span.title Open in GitHub--><span class="icon -github"></span></a>
          </div>
        </div>
        <div class="markdown-body"><h1 id="react">React</h1>
<p>React is an open-source frontend JavaScript library which is used for building user interfaces especially for single page applications.</p>
<p>The major features of React are:</p>
<ul>
<li>It uses VirtualDOM instead of RealDOM considering that RealDOM manipulations are expensive.</li>
<li>Supports server-side rendering.</li>
<li>Follows Unidirectional data flow or data binding.</li>
<li>Uses reusable/composable UI components to develop the view.</li>
<li>JSX makes code easy to read and write.</li>
</ul>
<h2 id="lifecycle">Lifecycle</h2>
<p>React 16.3+</p>
<p><strong>Reconciliation</strong>
: When a component&apos;s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM. This process is called <em>reconciliation</em>.</p>
<p><strong>getDerivedStateFromProps</strong>
: Invoked right before calling <code>render()</code> and is invoked on every render. This exists for rare use cases where you need derived state. Worth reading if you need derived state.</p>
<p><strong>componentDidMount</strong>
: Executed after first rendering and where all AJAX requests, DOM or state updates, and set up event listeners should occur.</p>
<p><strong>shouldComponentUpdate</strong>
: Determines if the component will be updated or not. By default it returns true. If you are sure that the component doesn&apos;t need to render after state or props are updated, you can return <code>false</code> value. It is a great place to improve performance as it allows you to prevent a re-render if component receives new prop.</p>
<p><strong>getSnapshotBeforeUpdate</strong>
: Executed right before rendered output is committed to the DOM. Any value returned by this will be passed into componentDidUpdate(). This is useful to capture information from the DOM i.e. scroll position.</p>
<p><strong>componentDidUpdate</strong>
: Mostly it is used to update the DOM in response to prop or state changes. This will not fire if <code>shouldComponentUpdate()</code> returns <code>false</code>.</p>
<p><strong>componentWillUnmount</strong>
: It will be used to cancel any outgoing network requests, or remove all event listeners associated with the component.</p>
<h3 id="mounting">Mounting</h3>
<p>These methods are called in the following order when an instance of a component is being created and inserted into the DOM:</p>
<ul>
<li><code>constructor()</code></li>
<li><code>static getDerivedStateFromProps()</code></li>
<li><code>render()</code></li>
<li><code>componentDidMount()</code></li>
</ul>
<h3 id="updating">Updating</h3>
<p>An update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered:</p>
<ul>
<li><code>static getDerivedStateFromProps()</code></li>
<li><code>shouldComponentUpdate()</code></li>
<li><code>render()</code></li>
<li><code>getSnapshotBeforeUpdate()</code></li>
<li><code>componentDidUpdate()</code></li>
</ul>
<h3 id="unmounting">Unmounting</h3>
<p>This method is called when a component is being removed from the DOM:</p>
<ul>
<li><code>componentWillUnmount()</code></li>
</ul>
<h3 id="error-handling">Error Handling</h3>
<p>These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.</p>
<ul>
<li><code>static getDerivedStateFromError()</code></li>
<li><code>componentDidCatch()</code></li>
</ul>
<h2 id="dom">DOM</h2>
<p>DOM stands for &#x201C;Document Object Model&#x201D;. The DOM in simple words represents the UI of your application. Everytime there is a change in the state of your application UI, the DOM gets updated to represent that change. Now the catch is frequently manipulating the DOM affects performance, making it slow.</p>
<p>The DOM is represented as a tree data structure. Because of that, the changes and updates to the DOM are fast. But after the change, the updated element and it&#x2019;s children have to be re-rendered to update the application UI. The re-rendering or re-painting of the UI is what makes it slow. Therefore, the more UI components you have, the more expensive the DOM updates could be, since they would need to be re-rendered for every DOM update.</p>
<h3 id="virtual-dom">Virtual DOM</h3>
<p>That&#x2019;s where the concept of virtual DOM comes in and performs significantly better than the real DOM. The virtual DOM is only a virtual representation of the DOM. Everytime the state of our application changes, the virtual DOM gets updated instead of the real DOM.</p>
<p>When new elements are added to the UI, a virtual DOM, which is represented as a tree is created. Each element is a node on this tree. If the state of any of these elements changes, a new virtual DOM tree is created. This tree is then compared or &#x201C;diffed&#x201D; with the previous virtual DOM tree.</p>
<p>Once this is done, the virtual DOM calculates the best possible method to make these changes to the real DOM. This ensures that there are minimal operations on the real DOM. Hence, reducing the performance cost of updating the real DOM.</p>
<p>The image below shows the virtual DOM tree and the diffing process.</p>
<p><img src="https://i0.wp.com/programmingwithmosh.com/wp-content/uploads/2018/11/lnrn_0201.png?resize=1024%2C685&amp;ssl=1" alt></p>
<p>The red circles represent the nodes that have changed. These nodes represent the UI elements that have had their state changed. The difference between the previous version of the virtual DOM tree and the current virtual DOM tree is then calculated. The whole parent subtree then gets re-rendered to give the updated UI. This updated tree is then batch updated to the real DOM.</p>
<p>In React every UI piece is a component, and each component has a state. React follows the observable pattern and listens for state changes. When the state of a component changes, React updates the virtual DOM tree. Once the virtual DOM has been updated, React then compares the current version of the virtual DOM with the previous version of the virtual DOM. This process is called &#x201C;diffing&#x201D;.</p>
<p>Once React knows which virtual DOM objects have changed, then React updates only those objects, in the real DOM. This makes the performance far better when compared to manipulating the real DOM directly. This makes React standout as a high performance JavaScript library.</p>
<h3 id="render()">render()</h3>
<p><code>render()</code> is where the UI gets updated and rendered. <code>render()</code> is the required lifecycle method in React.</p>
<p><code>render()</code> is the point of entry where the tree of React elements are created. When a state or prop within the component is updated, the <code>render()</code> will return a different tree of React elements. If you use <code>setState()</code> within the component, React immediately detects the state change and re-renders the component.</p>
<p>React then figures out how to efficiently update the UI to match the most recent tree changes.</p>
<p>This is when React updates its virtual DOM first and updates only the object that have changed in the real DOM.</p>
<p>React follows a batch update mechanism to update the real DOM. Hence, leading to increased performance. This means that updates to the real DOM are sent in batches, instead of sending updates for every single change in state.</p>
<p>The repainting of the UI is the most expensive part, and React efficiently ensures that the real DOM receives only batched updates to repaint the UI.</p>
<h2 id="components">Components</h2>
<p>A component can be declared in several different ways. It can be a class with a <code>render()</code> method. Alternatively, in simple cases, it can be defined as a function. In either case, it takes props as an input, and returns a JSX tree as the output:</p>
<pre><code class="lang-js"><span class="pl-k">const</span> Button = <span class="hljs-function">(<span class="hljs-params">{ onLogin }</span>) =&gt;</span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="pl-s">{</span>&apos;<span class="hljs-attr">login-btn</span>&apos;} <span class="hljs-attr">onClick</span>=<span class="pl-s">{onLogin}</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre>
<p>Then JSX gets transpiled to a <code>React.createElement()</code> function tree:</p>
<p><em>JSX is a XML-like syntax extension to ECMAScript (the acronym stands for JavaScript XML). Basically it just provides syntactic sugar for the React.createElement() function, giving us expressiveness of JavaScript along with HTML like template syntax.</em></p>
<pre><code class="lang-js"><span class="pl-k">const</span> Button = <span class="hljs-function">(<span class="hljs-params">{ onLogin }</span>) =&gt;</span> React.createElement(
  <span class="pl-s">&apos;div&apos;</span>,
  { <span class="hljs-attr">id</span>: <span class="pl-s">&apos;login-btn&apos;</span>, <span class="hljs-attr">onClick</span>: onLogin },
  <span class="pl-s">&apos;Login&apos;</span>
)
</code></pre>
<p>The above <code>React.createElement()</code> function returns an object:</p>
<pre><code class="lang-js">{
  <span class="hljs-attr">type</span>: <span class="pl-s">&apos;div&apos;</span>,
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">children</span>: <span class="pl-s">&apos;Login&apos;</span>,
    <span class="hljs-attr">id</span>: <span class="pl-s">&apos;login-btn&apos;</span>
  }
}
</code></pre>
<p>And finally it renders to the DOM using <code>ReactDOM.render()</code>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="pl-s">&apos;login-btn&apos;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h3 id="types">Types</h3>
<p><strong>Function Components:</strong> This is the simplest way to create a component. Those are pure JavaScript functions that accept props object as first parameter and return React elements:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="pl-k">function</span> <span class="pl-ent">Greeting</span>(<span class="hljs-params">{ message }</span>) </span>{
  <span class="pl-k">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{`Hello, ${message}`}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>

}
</code></pre>
<p><strong>Class Components:</strong> You can also use ES6 class to define a component. The above function component can be written as:</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">Greeting</span> <span class="pl-k">extends</span> <span class="pl-ent">React</span>.<span class="pl-ent">Component</span> </span>{
  render() {
    <span class="pl-k">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{`Hello, ${this.props.message}`}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
  }
}
</code></pre>
<p><strong>Controlled Components:</strong> A component that controls the input elements within the forms on subsequent user input.</p>
<pre><code class="lang-js">handleChange(event) {
  <span class="pl-k">this</span>.setState({<span class="hljs-attr">value</span>: event.target.value.toUpperCase()})
}
</code></pre>
<p><strong>Uncontrolled Components:</strong> are the ones that store their own state internally, and you query the DOM using a ref to find its current value when you need it. This is a bit more like traditional HTML.</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">UserProfile</span> <span class="pl-k">extends</span> <span class="pl-ent">React</span>.<span class="pl-ent">Component</span> </span>{
  <span class="pl-k">constructor</span>(props) {
    <span class="pl-k">super</span>(props)
    <span class="pl-k">this</span>.handleSubmit = <span class="pl-k">this</span>.handleSubmit.bind(<span class="pl-k">this</span>)
    <span class="pl-k">this</span>.input = React.createRef()
  }

  handleSubmit(event) {
    alert(<span class="pl-s">&apos;A name was submitted: &apos;</span> + <span class="pl-k">this</span>.input.current.value)
    event.preventDefault()
  }

  render() {
    <span class="pl-k">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="pl-s">{this.handleSubmit}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>
          {&apos;Name:&apos;}
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="pl-s">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="pl-s">{this.input}</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="pl-s">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="pl-s">&quot;Submit&quot;</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
    );
  }
}
</code></pre>
<p>In most cases, it&apos;s recommend to use <em>controlled components</em> to implement forms.</p>
<p><strong>Higher-Order Components (HOC)</strong> are functions that take a component and return a new component. Basically, it&apos;s a pattern that is derived from React&apos;s compositional nature.</p>
<p>We call them pure components because they can accept any dynamically provided child component but they won&apos;t modify or copy any behavior from their input components.</p>
<pre><code class="lang-js"><span class="pl-k">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent)
</code></pre>
<p>HOC can be used for many use cases:</p>
<ul>
<li>Code reuse, logic and bootstrap abstraction.</li>
<li>Render hijacking.</li>
<li>State abstraction and manipulation.</li>
<li>Props manipulation.</li>
</ul>
<p>You can add/edit props passed to the component using <em>props proxy</em> pattern like this:</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="pl-k">function</span> <span class="pl-ent">HOC</span>(<span class="hljs-params">WrappedComponent</span>) </span>{
  <span class="pl-k">return</span> <span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">Test</span> <span class="pl-k">extends</span> <span class="pl-ent">Component</span> </span>{
    render() {
      <span class="pl-k">const</span> newProps = {
        <span class="hljs-attr">title</span>: <span class="pl-s">&apos;New Header&apos;</span>,
        <span class="hljs-attr">footer</span>: <span class="pl-c1">false</span>,
        <span class="hljs-attr">showFeatureX</span>: <span class="pl-c1">false</span>,
        <span class="hljs-attr">showFeatureY</span>: <span class="pl-c1">true</span>
      }

      <span class="pl-k">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...this.props</span>} {<span class="hljs-attr">...newProps</span>} /&gt;</span></span>
    }
  }
}
</code></pre>
<p><strong>Switching Component</strong>
: is a component that renders one of many components. We need to use object to map prop values to components.</p>
<pre><code class="lang-jsx"><span class="pl-k">import</span> HomePage <span class="pl-k">from</span> <span class="pl-s">&apos;./HomePage&apos;</span>
<span class="pl-k">import</span> AboutPage <span class="pl-k">from</span> <span class="pl-s">&apos;./AboutPage&apos;</span>
<span class="pl-k">import</span> ServicesPage <span class="pl-k">from</span> <span class="pl-s">&apos;./ServicesPage&apos;</span>
<span class="pl-k">import</span> ContactPage <span class="pl-k">from</span> <span class="pl-s">&apos;./ContactPage&apos;</span>

<span class="pl-k">const</span> PAGES = {
  <span class="hljs-attr">home</span>: HomePage,
  <span class="hljs-attr">about</span>: AboutPage,
  <span class="hljs-attr">services</span>: ServicesPage,
  <span class="hljs-attr">contact</span>: ContactPage
}

<span class="pl-k">const</span> Page = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="pl-k">const</span> Handler = PAGES[props.page] || ContactPage

  <span class="pl-k">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Handler</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>
}

<span class="pl-c">// The keys of the PAGES object can be used in the prop types to catch dev-time errors.</span>
Page.propTypes = {
  <span class="hljs-attr">page</span>: PropTypes.oneOf(<span class="pl-c1">Object</span>.keys(PAGES)).isRequired
}
</code></pre>
<h3 id="binding">Binding</h3>
<ol>
<li><strong>Binding in Constructor:</strong> In JavaScript classes, the methods are not bound by default. The same thing applies for React event handlers defined as class methods. Normally we bind them in constructor.</li>
</ol>
<pre><code class="lang-js"><span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">Component</span> <span class="pl-k">extends</span> <span class="pl-ent">React</span>.<span class="pl-ent">Component</span> </span>{
  <span class="pl-k">constructor</span>(props) {
    <span class="pl-k">super</span>(props)
    <span class="pl-k">this</span>.handleClick = <span class="pl-k">this</span>.handleClick.bind(<span class="pl-k">this</span>)
  }

  handleClick() {
    <span class="pl-c">// ...</span>
  }
}
</code></pre>
<ol start="2">
<li><strong>Public class fields syntax:</strong> If you don&apos;t like to use bind approach then public class fields syntax can be used to correctly bind callbacks.</li>
</ol>
<pre><code class="lang-js">handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="pl-c1">console</span>.log(<span class="pl-s">&apos;this is:&apos;</span>, <span class="pl-k">this</span>)
}
</code></pre>
<pre><code class="lang-js">&lt;button onClick={this.handleClick}&gt;
  {&apos;Click me&apos;}
&lt;/button&gt;
</code></pre>
<ol start="3">
<li><strong>Arrow functions in callbacks:</strong> You can use arrow functions directly in the callbacks.</li>
</ol>
<pre><code class="lang-js">&lt;button onClick={(event) =&gt; this.handleClick(event)}&gt;
  {&apos;Click me&apos;}
&lt;/button&gt;
</code></pre>
<p><strong>Note:</strong> If the callback is passed as prop to child components, those components might do an extra re-rendering. In those cases, it is preferred to go with <code>.bind()</code> or <em>public class fields syntax</em> approach considering performance.</p>
<h3 id="context">Context</h3>
<p><em>Context</em> provides a way to pass data through the component tree without having to pass props down manually at every level.</p>
<p>For example, authenticated user, locale preference, UI theme need to be accessed in the application by many components.</p>
<pre><code class="lang-javascript"><span class="pl-k">const</span> {Provider, Consumer} = React.createContext(defaultValue)
</code></pre>
<h3 id="constructor">Constructor</h3>
<p>A child class constructor cannot make use of <code>this</code> reference until <code>super()</code> method has been called. The same applies for ES6 sub-classes as well. The main reason of passing props parameter to <code>super()</code> call is to access <code>this.props</code> in your child constructors.</p>
<p><strong>Passing props:</strong></p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">MyComponent</span> <span class="pl-k">extends</span> <span class="pl-ent">React</span>.<span class="pl-ent">Component</span> </span>{
  <span class="pl-k">constructor</span>(props) {
    <span class="pl-k">super</span>(props)

    <span class="pl-c1">console</span>.log(<span class="pl-k">this</span>.props) <span class="pl-c">// prints { name: &apos;John&apos;, age: 42 }</span>
  }
}
</code></pre>
<p><strong>Not passing props:</strong></p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">MyComponent</span> <span class="pl-k">extends</span> <span class="pl-ent">React</span>.<span class="pl-ent">Component</span> </span>{
  <span class="pl-k">constructor</span>(props) {
    <span class="pl-k">super</span>()

    <span class="pl-c1">console</span>.log(<span class="pl-k">this</span>.props) <span class="pl-c">// prints undefined</span>

    <span class="pl-c">// but props parameter is still available</span>
    <span class="pl-c1">console</span>.log(props) <span class="pl-c">// prints { name: &apos;John&apos;, age: 42 }</span>
  }

  render() {
    <span class="pl-c">// no difference outside constructor</span>
    <span class="pl-c1">console</span>.log(<span class="pl-k">this</span>.props) <span class="pl-c">// prints { name: &apos;John&apos;, age: 42 }</span>
  }
}
</code></pre>
<p>The above code snippets reveals that <code>this.props</code> is different only within the constructor. It would be the same outside the constructor.</p>
<h3 id="fragments">Fragments</h3>
<p>It&apos;s common pattern in React which is used for a component to return multiple elements. <em>Fragments</em> let you group a list of children without adding extra nodes to the DOM.</p>
<pre><code class="lang-jsx">render() {
  <span class="pl-k">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ChildC</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span>
  )
}
</code></pre>
<ul>
<li>Fragments are a bit faster and use less memory by not creating an extra DOM node. This only has a real benefit on very large and deep trees.</li>
<li>Some CSS mechanisms like <em>Flexbox</em> and <em>CSS Grid</em> have a special parent-child relationships, and adding divs in the middle makes it hard to keep the desired layout.</li>
<li>The DOM Inspector is less cluttered.</li>
</ul>
<h3 id="error-boundaries">Error Boundaries</h3>
<p><em>Error boundaries</em> are components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed.</p>
<p>A class component becomes an error boundary if it defines a new lifecycle method called <code>componentDidCatch(error, info)</code> or <code>static getDerivedStateFromError() </code>:</p>
<pre><code class="lang-jsx"><span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">ErrorBoundary</span> <span class="pl-k">extends</span> <span class="pl-ent">React</span>.<span class="pl-ent">Component</span> </span>{
  <span class="pl-k">constructor</span>(props) {
    <span class="pl-k">super</span>(props)
    <span class="pl-k">this</span>.state = { <span class="hljs-attr">hasError</span>: <span class="pl-c1">false</span> }
  }

  componentDidCatch(error, info) {
    <span class="pl-c">// You can also log the error to an error reporting service</span>
    logErrorToMyService(error, info)
  }

  <span class="pl-k">static</span> getDerivedStateFromError(error) {
     <span class="pl-c">// Update state so the next render will show the fallback UI.</span>
     <span class="pl-k">return</span> { <span class="hljs-attr">hasError</span>: <span class="pl-c1">true</span> };
   }

  render() {
    <span class="pl-k">if</span> (<span class="pl-k">this</span>.state.hasError) {
      <span class="pl-c">// You can render any custom fallback UI</span>
      <span class="pl-k">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{&apos;Something went wrong.&apos;}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
    }
    <span class="pl-k">return</span> <span class="pl-k">this</span>.props.children
  }
}
</code></pre>
<p>After that use it as a regular component:</p>
<pre><code class="lang-jsx">&lt;ErrorBoundary&gt;
  &lt;MyWidget /&gt;
&lt;/ErrorBoundary&gt;
</code></pre>
<h3 id="rendering">Rendering</h3>
<p>By default, when your component&apos;s state or props change, your component will re-render. If your <code>render()</code> method depends on some other data, you can tell React that the component needs re-rendering by calling <code>forceUpdate()</code>.</p>
<pre><code class="lang-javascript">component.forceUpdate(callback)
</code></pre>
<p>It is recommended to avoid all uses of <code>forceUpdate()</code> and only read from <code>this.props</code> and <code>this.state</code> in <code>render()</code>.</p>
<h2 id="hooks">Hooks</h2>
<p>Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.</p>
<p>Hooks are JavaScript functions, but they impose two additional rules:</p>
<ul>
<li>Only call Hooks at the top level. Don&#x2019;t call Hooks inside loops, conditions, or nested functions.</li>
<li>Only call Hooks from React function components. Don&#x2019;t call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks &#x2014; your own custom Hooks.)</li>
</ul>
<p><a href="https://reactjs.org/docs/hooks-overview.html">https://reactjs.org/docs/hooks-overview.html</a></p>
<h3 id="state-hooks">State Hooks</h3>
<pre><code class="lang-js"><span class="pl-k">import</span> React, { useState } <span class="pl-k">from</span> <span class="pl-s">&apos;react&apos;</span>;

<span class="hljs-function"><span class="pl-k">function</span> <span class="pl-ent">Example</span>(<span class="hljs-params"></span>) </span>{
  <span class="pl-k">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);
  
  <span class="pl-k">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked {count} times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="pl-s">{()</span> =&gt;</span> setCount(count + 1)}&gt;
        Click me
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>We declare a state variable called <code>count</code>, and set it to <code>0</code>. React will remember its current value between re-renders, and provide the most recent one to our function. If we want to update the current <code>count</code>, we can call <code>setCount</code>.</p>
<p>The only argument to the <code>useState()</code> Hook is the initial state.</p>
<p><code>useState</code> returns a pair of values: the current state and a function that updates it. This is why we write <code>const [count, setCount] = useState(0)</code>. This is similar to <code>this.state.count</code> and <code>this.setState</code> in a class, except you get them in a pair.</p>
<p>The names on the left aren&#x2019;t a part of the React API. You can name your own state variables:</p>
<pre><code class="lang-js">  <span class="pl-k">const</span> [fruit, setFruit] = useState(<span class="pl-s">&apos;banana&apos;</span>);
</code></pre>
<pre><code class="lang-js"><span class="hljs-function"><span class="pl-k">function</span> <span class="pl-ent">handleOrangeClick</span>(<span class="hljs-params"></span>) </span>{
  <span class="pl-c">// Similar to this.setState({ fruit: &apos;orange&apos; })</span>
  setFruit(<span class="pl-s">&apos;orange&apos;</span>);
}
</code></pre>
<p>Unlike <code>this.setState</code> in a class, updating a state variable always <em>replaces</em> it instead of merging it.</p>
<h2 id="props">Props</h2>
<p>Props are inputs to components. They are single values or objects containing a set of values that are passed to components on creation using a naming convention similar to HTML-tag attributes. They are data passed down from a parent component to a child component.</p>
<p>The primary purpose of props in React is to provide following component functionality:</p>
<ul>
<li>Pass custom data to your component.</li>
<li>Trigger state changes.</li>
<li>Use via this.props.reactProp inside component&apos;s render() method.</li>
</ul>
<pre><code class="lang-js">&lt;Element reactProp={<span class="pl-s">&apos;1&apos;</span>} /&gt;
</code></pre>
<p>This <code>reactProp</code> name then becomes a property attached to React&apos;s native props object which originally already exists on all components created using React library.</p>
<h3 id="validating">Validating</h3>
<p>When the application is running in <em>development mode</em>, React will automatically check all props that we set on components to make sure they have <em>correct type</em>. If the type is incorrect, React will generate warning messages in the console. It&apos;s disabled in <em>production mode</em> due to performance impact. The mandatory props are defined with <code>isRequired</code>.</p>
<p>The set of predefined prop types:</p>
<ul>
<li><code>PropTypes.number</code></li>
<li><code>PropTypes.string</code></li>
<li><code>PropTypes.array</code></li>
<li><code>PropTypes.object</code></li>
<li><code>PropTypes.func</code></li>
<li><code>PropTypes.node</code></li>
<li><code>PropTypes.element</code></li>
<li><code>PropTypes.bool</code></li>
<li><code>PropTypes.symbol</code></li>
<li><code>PropTypes.any</code></li>
</ul>
<p>We can define <code>propTypes</code> for <code>User</code> component as below:</p>
<pre><code class="lang-jsx"><span class="pl-k">import</span> React <span class="pl-k">from</span> <span class="pl-s">&apos;react&apos;</span>
<span class="pl-k">import</span> PropTypes <span class="pl-k">from</span> <span class="pl-s">&apos;prop-types&apos;</span>

<span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">User</span> <span class="pl-k">extends</span> <span class="pl-ent">React</span>.<span class="pl-ent">Component</span> </span>{
  <span class="pl-k">static</span> propTypes = {
    <span class="hljs-attr">name</span>: PropTypes.string.isRequired,
    <span class="hljs-attr">age</span>: PropTypes.number.isRequired
  }

  render() {
    <span class="pl-k">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{`Welcome, ${this.props.name}`}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{`Age, ${this.props.age}`}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;/&gt;</span></span>
    )
  }
}
</code></pre>
<p><strong>Note:</strong> In React v15.5 <em>PropTypes</em> were moved from <code>React.PropTypes</code> to <code>prop-types</code> library.</p>
<p><em>The Equivalent Functional Component</em></p>
<pre><code class="lang-jsx"><span class="pl-k">import</span> React <span class="pl-k">from</span> <span class="pl-s">&apos;react&apos;</span>
<span class="pl-k">import</span> PropTypes <span class="pl-k">from</span> <span class="pl-s">&apos;prop-types&apos;</span>

<span class="hljs-function"><span class="pl-k">function</span> <span class="pl-ent">User</span>(<span class="hljs-params"></span>) </span>{
  <span class="pl-k">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{`Welcome, ${this.props.name}`}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{`Age, ${this.props.age}`}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}

User.propTypes = {
  <span class="hljs-attr">name</span>: PropTypes.string.isRequired,
  <span class="hljs-attr">age</span>: PropTypes.number.isRequired
}
</code></pre>
<p>If you want to pass an array of objects to a component with a particular shape then use <code>React.PropTypes.shape()</code> as an argument to <code>React.PropTypes.arrayOf()</code>.</p>
<pre><code class="lang-javascript">ReactComponent.propTypes = {
  <span class="hljs-attr">arrayWithShape</span>: React.PropTypes.arrayOf(React.PropTypes.shape({
    <span class="hljs-attr">color</span>: React.PropTypes.string.isRequired,
    <span class="hljs-attr">fontSize</span>: React.PropTypes.number.isRequired
  })).isRequired
}
</code></pre>
<h3 id="refreshing">Refreshing</h3>
<p>If the props on the component are changed without the component being refreshed, the new prop value will never be displayed because the constructor function will never update the current state of the component. The initialization of state from props only runs when the component is first created.</p>
<p>The below component won&apos;t display the updated input value:</p>
<pre><code class="lang-jsx"><span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">MyComponent</span> <span class="pl-k">extends</span> <span class="pl-ent">React</span>.<span class="pl-ent">Component</span> </span>{
  <span class="pl-k">constructor</span>(props) {
    <span class="pl-k">super</span>(props)

    <span class="pl-k">this</span>.state = {
      <span class="hljs-attr">records</span>: [],
      <span class="hljs-attr">inputValue</span>: <span class="pl-k">this</span>.props.inputValue
    };
  }

  render() {
    <span class="pl-k">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.state.inputValue}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  }
}
</code></pre>
<p>Using props inside render method will update the value:</p>
<pre><code class="lang-jsx"><span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">MyComponent</span> <span class="pl-k">extends</span> <span class="pl-ent">React</span>.<span class="pl-ent">Component</span> </span>{
  <span class="pl-k">constructor</span>(props) {
    <span class="pl-k">super</span>(props)

    <span class="pl-k">this</span>.state = {
      <span class="hljs-attr">record</span>: []
    }
  }

  render() {
    <span class="pl-k">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.props.inputValue}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  }
}
</code></pre>
<h3 id="spread">Spread</h3>
<p>When we <em>spread props</em> we run into the risk of adding unknown attributes, which is a bad practice. Instead we can use prop destructuring with <code>...rest</code> operator, so it will add only required props.</p>
<pre><code class="lang-jsx"><span class="pl-k">const</span> ComponentA = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentB</span> <span class="hljs-attr">isDisplay</span>=<span class="pl-s">{true}</span> <span class="hljs-attr">className</span>=<span class="pl-s">{</span>&apos;<span class="hljs-attr">componentStyle</span>&apos;} /&gt;</span></span>

<span class="pl-k">const</span> ComponentB = <span class="hljs-function">(<span class="hljs-params">{ isDisplay, ...domProps }</span>) =&gt;</span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> {<span class="hljs-attr">...domProps</span>}&gt;</span>{&apos;ComponentB&apos;}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre>
<h2 id="state">State</h2>
<p>State of a component is an object that holds some information that may change over the lifetime of the component. We should always try to make our state as simple as possible and minimize the number of stateful components.</p>
<p>State is similar to props, but it is private and fully controlled by the component. i.e, It is not accessible to any component other than the one that owns and sets it.</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">User</span> <span class="pl-k">extends</span> <span class="pl-ent">React</span>.<span class="pl-ent">Component</span> </span>{
  <span class="pl-k">constructor</span>(props) {
    <span class="pl-k">super</span>(props)

    <span class="pl-k">this</span>.state = {
      <span class="hljs-attr">message</span>: <span class="pl-s">&apos;Welcome to React world&apos;</span>
    }
  }

  render() {
    <span class="pl-k">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{this.state.message}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}
</code></pre>
<p>If you are using ES6 or the Babel transpiler to transform your JSX code then you can set state with a dynamic key name, with computed property names.</p>
<pre><code class="lang-js">handleInputChange(event) {
  <span class="pl-k">this</span>.setState({ [event.target.id]: event.target.value })
}
</code></pre>
<p>When you use <code>setState()</code> the current and previous states are merged. <code>replaceState()</code> throws out the current state, and replaces it with only what you provide. Usually <code>setState()</code> is used unless you really need to remove all previous keys for some reason. You can also set state to <code>false</code>/<code>null</code> in <code>setState()</code> instead of using <code>replaceState()</code>.</p>
<h3 id="callbacks">Callbacks</h3>
<p>The callback function is invoked when <code>setState()</code> finishes and the component gets rendered. Since <code>setState()</code> is asynchronous the callback function is used for any post action.</p>
<p><strong>Note:</strong> It is recommended to use lifecycle methods rather than a callback function.</p>
<pre><code class="lang-js">setState({ <span class="hljs-attr">name</span>: <span class="pl-s">&apos;John&apos;</span> }, () =&gt; <span class="pl-c1">console</span>.log(<span class="pl-s">&apos;The name has updated and component re-rendered&apos;</span>))
</code></pre>
<p>The reason behind this is that <code>setState()</code> is an asynchronous operation. React batches state changes for performance reasons, so the state may not change immediately after <code>setState()</code> is called. That means you should not rely on the current state when calling <code>setState()</code>&#x200A;since you can&apos;t be sure what that state will be. The solution is to  pass a function to <code>setState()</code>, with the previous state as an argument. By doing this you can avoid issues with the user getting the old state value on access due to the asynchronous nature of <code>setState()</code>.</p>
<p>Let&apos;s say the initial count value is zero. After three consecutive increment operations, the value is going to be incremented only by one.</p>
<pre><code class="lang-javascript"><span class="pl-c">// assuming this.state.count === 0</span>
<span class="pl-k">this</span>.setState({ <span class="hljs-attr">count</span>: <span class="pl-k">this</span>.state.count + <span class="hljs-number">1</span> })
<span class="pl-k">this</span>.setState({ <span class="hljs-attr">count</span>: <span class="pl-k">this</span>.state.count + <span class="hljs-number">1</span> })
<span class="pl-k">this</span>.setState({ <span class="hljs-attr">count</span>: <span class="pl-k">this</span>.state.count + <span class="hljs-number">1</span> })
<span class="pl-c">// this.state.count === 1, not 3</span>
</code></pre>
<p>If we pass a function to <code>setState()</code>, the count gets incremented correctly.</p>
<pre><code class="lang-javascript"><span class="pl-k">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">prevState, props</span>) =&gt;</span> ({
  <span class="hljs-attr">count</span>: prevState.count + props.increment
}))
<span class="pl-c">// this.state.count === 3 as expected</span>
</code></pre>
<h2 id="todo">TODO</h2>
<p><a href>https://itnext.io/reactjs-interview-questions-for-senior-developers-64618f6a0aca</a></p>
<ul>
<li>ES6</li>
<li>Babel</li>
<li>Redux</li>
<li>CDN</li>
<li>JSX</li>
<li>TypeScript</li>
</ul>

        </div>
        <div class="footer-nav">
          <div class="left"><a href="../javascript/properties.html"><span class="title">Properties</span></a></div>
          <div class="right"><a href="../javascript/variables.html"><span class="label">Next: </span><span class="title">Variables</span></a></div>
        </div>
      </div>
    </div>
  </body>
</html>